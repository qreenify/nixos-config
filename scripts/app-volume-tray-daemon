#!/usr/bin/env python3
"""
System tray daemon for per-application volume control.
Creates individual tray icons for each audio stream with click-to-mute functionality.
"""

import gi
gi.require_version('Gtk', '3.0')
gi.require_version('AppIndicator3', '0.1')
from gi.repository import Gtk, AppIndicator3, GLib
import subprocess
import json
import os
import time
from pathlib import Path

class StreamIcon:
    """Represents a single audio stream with its tray icon"""

    def __init__(self, app_type, stream_id, volume, muted, window_title, manager):
        self.app_type = app_type
        self.stream_id = stream_id
        self.volume = volume
        self.muted = muted
        self.window_title = window_title
        self.manager = manager

        # App-specific configuration
        self.config = self._get_app_config()

        # Create indicator
        unique_id = f"app-volume-{app_type}-{stream_id}"
        self.indicator = AppIndicator3.Indicator.new(
            unique_id,
            self.config['icon_path'],
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS
        )
        self.indicator.set_status(AppIndicator3.IndicatorStatus.ACTIVE)

        # Create menu
        self.menu = Gtk.Menu()

        # Title item (non-clickable)
        title_item = Gtk.MenuItem(label=self._get_title_text())
        title_item.set_sensitive(False)
        self.menu.append(title_item)

        # Mute toggle
        self.mute_item = Gtk.MenuItem(label="Unmute" if muted else "Mute")
        self.mute_item.connect("activate", self.toggle_mute)
        self.menu.append(self.mute_item)

        self.menu.show_all()
        self.indicator.set_menu(self.menu)

    def _get_app_config(self):
        """Get app-specific configuration"""
        configs = {
            'youtube': {
                'name': 'YouTube',
                'icon_path': str(Path.home() / '.local/share/icons/youtube.png'),
                'color': '#FF0000'
            },
            'twitch': {
                'name': 'Twitch',
                'icon_path': str(Path.home() / '.local/share/icons/twitch.png'),
                'color': '#9146FF'
            },
            'apple-music': {
                'name': 'Apple Music',
                'icon_path': str(Path.home() / '.local/share/icons/music.png'),
                'color': '#FA243C'
            },
            'plex': {
                'name': 'Plex',
                'icon_path': str(Path.home() / '.local/share/icons/plex.png'),
                'color': '#E5A00D'
            },
            'jellyfin': {
                'name': 'Jellyfin',
                'icon_path': str(Path.home() / '.local/share/icons/jellyfin.png'),
                'color': '#00A4DC'
            },
            'vesktop': {
                'name': 'Discord',
                'icon_path': '/run/current-system/sw/share/icons/hicolor/32x32/apps/vesktop.png',
                'color': '#5865F2'
            }
        }

        if self.app_type in configs:
            return configs[self.app_type]

        # Handle generic apps
        if self.app_type.startswith('generic-'):
            proc_name = self.app_type.replace('generic-', '')
            # Try to find system icon for this app
            icon_path = self._find_app_icon(proc_name)
            return {
                'name': proc_name.title(),
                'icon_path': icon_path,
                'color': '#888888'
            }

        return {
            'name': self.app_type.title(),
            'icon_path': 'audio-volume-high',
            'color': '#888888'
        }

    def _find_app_icon(self, app_name):
        """Try to find system icon for an app"""
        # Common icon search paths
        icon_paths = [
            f'/run/current-system/sw/share/icons/hicolor/48x48/apps/{app_name}.png',
            f'/run/current-system/sw/share/icons/hicolor/32x32/apps/{app_name}.png',
            f'/run/current-system/sw/share/pixmaps/{app_name}.png',
            f'/run/current-system/sw/share/pixmaps/{app_name}.xpm',
        ]

        for path in icon_paths:
            if Path(path).exists():
                return path

        # Fallback to generic audio icon
        return 'audio-volume-high'

    def _get_title_text(self):
        """Get display text for title"""
        name = self.config['name']
        vol_text = f"{self.volume}%"
        if self.muted:
            return f"{name}: MUTED ({vol_text})"
        return f"{name}: {vol_text}"

    def update(self, volume, muted, window_title):
        """Update icon state"""
        self.volume = volume
        self.muted = muted
        self.window_title = window_title

        # Update menu
        for item in self.menu.get_children():
            self.menu.remove(item)

        # Re-create menu items
        title_item = Gtk.MenuItem(label=self._get_title_text())
        title_item.set_sensitive(False)
        self.menu.append(title_item)

        if window_title and window_title != "Unknown":
            window_item = Gtk.MenuItem(label=f"Window: {window_title}")
            window_item.set_sensitive(False)
            self.menu.append(window_item)

        self.mute_item = Gtk.MenuItem(label="Unmute" if muted else "Mute")
        self.mute_item.connect("activate", self.toggle_mute)
        self.menu.append(self.mute_item)

        self.menu.show_all()

    def toggle_mute(self, widget=None):
        """Toggle mute state"""
        subprocess.run(['wpctl', 'set-mute', str(self.stream_id), 'toggle'],
                      capture_output=True)
        # Update will happen on next poll

    def destroy(self):
        """Remove the indicator"""
        self.indicator.set_status(AppIndicator3.IndicatorStatus.PASSIVE)


class VolumeIconManager:
    """Manages all stream icons"""

    def __init__(self):
        self.icons = {}  # stream_id -> StreamIcon
        self.monitor_script = self._find_monitor_script()
        self.focus_tracker = FocusTracker()

    def _find_monitor_script(self):
        """Find the app-volume-monitor-multi script"""
        paths = [
            Path.home() / '.script/app-volume-monitor-multi',
            Path.home() / '.config/nixos/scripts/app-volume-monitor-multi'
        ]
        for path in paths:
            if path.exists() and os.access(path, os.X_OK):
                return str(path)
        return None

    def get_streams(self):
        """Get current streams from monitor script (returns list of stream objects)"""
        if not self.monitor_script:
            return []

        try:
            result = subprocess.run([self.monitor_script],
                                   capture_output=True, text=True, timeout=5)
            if result.returncode == 0:
                return json.loads(result.stdout)
        except Exception as e:
            print(f"Error getting streams: {e}")
        return []

    def update_icons(self):
        """Update all icons based on current streams"""
        streams = self.get_streams()
        current_stream_ids = set()

        for stream_data in streams:
            stream_id = stream_data['stream_id']
            app_type = stream_data['app']
            volume = stream_data['volume']
            muted = stream_data['muted']
            window_title = stream_data.get('title', 'Unknown')

            current_stream_ids.add(stream_id)

            if stream_id in self.icons:
                # Update existing icon
                self.icons[stream_id].update(volume, muted, window_title)
            else:
                # Create new icon
                self.icons[stream_id] = StreamIcon(
                    app_type, stream_id, volume, muted, window_title, self
                )

        # Remove icons for streams that no longer exist
        for stream_id in list(self.icons.keys()):
            if stream_id not in current_stream_ids:
                self.icons[stream_id].destroy()
                del self.icons[stream_id]

        return True  # Continue polling

    def start(self):
        """Start the manager"""
        # Initial update
        self.update_icons()

        # Poll every second
        GLib.timeout_add(1000, self.update_icons)

        # Start GTK main loop
        Gtk.main()


class FocusTracker:
    """Tracks window focus to determine active stream per app"""

    def __init__(self):
        self.window_titles = {}  # app_type -> window_title
        self.update_focus()

    def update_focus(self):
        """Update focused window info from Hyprland"""
        try:
            result = subprocess.run(
                ['hyprctl', 'activewindow', '-j'],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                data = json.loads(result.stdout)
                # Extract window title and try to match to app
                # This is a simplified version - we'd need PID matching for accuracy
                pass
        except Exception:
            pass

        # Schedule next update
        GLib.timeout_add(500, self.update_focus)
        return False

    def get_window_title_for_app(self, app_type):
        """Get window title for given app type"""
        return self.window_titles.get(app_type, "Unknown")


if __name__ == '__main__':
    manager = VolumeIconManager()
    manager.start()
